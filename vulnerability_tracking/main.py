import pickle
import requests
import logging

from collections import defaultdict
from fastapi import FastAPI, HTTPException, UploadFile
from redis import Redis
from typing import Union, Any

from vulnerability_tracking.models import Package, Dependency, Project
from vulnerability_tracking.settings import settings

app = FastAPI()
logger = logging.getLogger(__name__)
# connect to Redis and initialize the global maps
cache = Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, db=settings.REDIS_DB)
cache.set("project_dict", pickle.dumps(defaultdict(Project)))
cache.set("dependency_vulnerability", pickle.dumps(defaultdict(bool)))

@app.get("/")
def read_root() -> str:
    """
    Return a welcome message to introduce the project.

    Returns:
        a welcome message string
    """
    return "Welcome! This a \"Python Project Vulnerability Tracking API System exercise\" for Morgan Stanley Interview."

@app.post("/project/")
async def create_projects(project_name: str, project_description: str, requirement: UploadFile) -> str:
    """
    Create a project by submitting a name, description, and requirements.txt file.

    This endpoint allows users to create a Python project and save in the project_dict map which located the cache.
    Also, the vulnerability of the dependencies in requirement.txt file is tracked and saved in the dependency_vulnerable map.

    Args:
        project_name: The name of the project.
        project_description: The description of the project.
        requirement: The requirement.txt file that contains all dependencies for the project

    Returns:
        a success message to confirm the project is created.
    
    Raises:
        HTTPException: If the request to OSV service failed.
    """
    # read the content of the requirement.txt file
    content = await requirement.read()
    dependency_vulnerability = pickle.loads(cache.get("dependency_vulnerability"))
    dependencies: dict[str, Dependency] = {}
    untracked_dependencies: list[Dependency] = []

    # split the file content by lines and loop on each line
    for line in content.decode("utf-8").split("\r\n"): 
        # verify if the line is a dependency
        if "==" in line and line[0] != "#":
            dependency = line.split("==")
            dependency_model = Dependency(package=Package(name=dependency[0]), version=dependency[1])
            dependencies[dependency[0]] = dependency_model
            # verify if the denpendency vulnerability is already tracked and saved
            if ((dependency[0], dependency[1])) not in  dependency_vulnerability:
                dependency_vulnerability[(dependency[0], dependency[1])] = False
                untracked_dependencies.append(dependency_model)

    # send request to OSV service to track the untracked denpendency vulnerability
    if untracked_dependencies:
        # prepare the curl request to OSV service
        headers = {"Content-Type": "application/json"}
        queries = [dependency.model_dump() for dependency in untracked_dependencies]
        payload = {"queries": queries}
        response = requests.post(settings.CHECK_MULTIPLE_PACKAGES, json=payload, headers=headers)

        # check the status code
        match response.status_code:
            case 200:
                # verify if the dependency is vulnerable and save in the dependency_vulnerability map
                index = 0
                for vulnerable in response.json()["results"]:
                    dependency = untracked_dependencies[index]
                    if vulnerable:
                        dependency_vulnerability[(dependency.package.name, dependency.version)] = True
                    index += 1
            case _:
                # raise runtime error if the status is not 200
                logger.error("Error occurred while sending request to OSV service.")
                raise HTTPException(status_code=response.json()["code"], detail=response.json()["message"])
            
        cache.set("dependency_vulnerability", pickle.dumps(dependency_vulnerability))

    # add the project in project_dict map
    project_dict = pickle.loads(cache.get("project_dict"))  
    project_dict[project_name] = Project(name=project_name, description=project_description, dependencies=dependencies)
    cache.set("project_dict", pickle.dumps(project_dict))
    
    return "Project successfully created!"

@app.get("/project/")
async def get_projects() -> list[dict[str, Union[str, bool]]]:
    """
    Retrieve the list of users’ projects and identify vulnerable projects.

    This endpoint retieves users' project and verify if it's vulnerable using the dependency_vulnerable map.

    Returns:
        list of the users’ projects with vulnerability identified.
    """
    # get project_dict and dependency_vulnerability from cache
    project_dict = pickle.loads(cache.get("project_dict"))
    dependency_vulnerability = pickle.loads(cache.get("dependency_vulnerability"))
    project_vulnerability: list[dict[str, Any]] = []

    # loop the project map
    for name, project in project_dict.items():
        returned_project = {"name": name, "description": project.description, "vulnerable": False}
        # loop the dependency map of the project and verify if it's vulnerable
        for dependency in project.dependencies.values():
            name_version_pair = (dependency.package.name, dependency.version)
            if  name_version_pair in dependency_vulnerability and dependency_vulnerability[name_version_pair]:
                returned_project["vulnerable"] = True
                break
        project_vulnerability.append(returned_project)
        
    return project_vulnerability

@app.get("/project/{project_name}/")
async def get_project_dependencies(project_name: str) -> list[dict[str, Union[str, bool]]]:
    """
    Retrieve the list of dependencies for the given project and identify which of these dependencies are vulnerable.

    This endpoint retieves the dependencies of the given project,
    and verify if it's vulnerable using the dependency_vulnerable map.

    Args:
        project_name: The name of the project.

    Returns:
        list of the dependencies of the given projects with vulnerability identified.

    Raises:
        HTTPException: If the given project does not exist.
    """
    # get project_dict and dependency_vulnerability from cache
    project_dict = pickle.loads(cache.get("project_dict"))
    dependency_vulnerability = pickle.loads(cache.get("dependency_vulnerability"))
    # validate the input project name, raise ValueError if the given name not exists
    if project_name not in project_dict:
        logger.error("Project doesn't exist! Please create the project first in order to execute the vulnerability tracking.")
        raise HTTPException(status_code=400,  detail="Project doesn't exist! Please create the project first in order to execute the vulnerability tracking.")

    project_dependency_vulnerability: list[dict[str, Union[str, bool]]]= []
    # get project from project map by project name
    project = project_dict[project_name]
    # loop the dependencies and verify if it's vulnerable
    for dependency in project.dependencies.values():
        returned_dependency = {"name": dependency.package.name, "version": dependency.version, "vulnerable": False}
        name_version_pair = (dependency.package.name, dependency.version)
        if  name_version_pair in dependency_vulnerability and dependency_vulnerability[name_version_pair]:
            returned_dependency["vulnerable"] = True
        project_dependency_vulnerability.append(returned_dependency)

    return project_dependency_vulnerability

@app.get("/dependency/")
async def get_dependencies() -> list[dict[str, Union[str, bool]]]:
    """
    Retrieve the list of dependencies tracked across the users' projects and identify which of these dependencies are vulnerable.

    This endpoint retieves the dependencies tracked across all the users' projects,
    and verify if it's vulnerable using the dependency_vulnerable map.

    Returns:
        list of all dependencies tracked across the projects.
    """
    # get project_dict and dependency_vulnerability from cache
    project_dict = pickle.loads(cache.get("project_dict"))
    dependency_vulnerability = pickle.loads(cache.get("dependency_vulnerability"))

    returned_dependency_map: dict[tuple[str, str], bool]= {}
    # loop the project map
    for project in project_dict.values():
        # loop the dependency map of the project and verify if it's vulnerable
        for dependency in project.dependencies.values():
            name_version_pair = (dependency.package.name, dependency.version)
            if name_version_pair not in returned_dependency_map:
                returned_dependency_map[name_version_pair] = False
                if name_version_pair in dependency_vulnerability and dependency_vulnerability[name_version_pair]:
                    returned_dependency_map[name_version_pair] = True

    return [{"name": key[0], "version": key[1], "vulnerable": value}for key, value in returned_dependency_map.items()]

@app.get("/dependency/{dependency_name}/{dependency_version}/")
async def get_dependencies(dependency_name: str, dependency_version: str) -> dict[str, Any]:
    """
    Retrieve the details about a specific dependency, including usage and associated vulnerabilities.

    This endpoint track the vulnerability of the given dependencies and verify its usage across user's projects.

    Args:
        dependency_name: The name of the dependency package.
        dependency_version: The version of the dependency package

    Returns:
        details of the given dependency.

    Raises:
        HTTPException: If the request to OSV service failed.
    """
    project_dict = pickle.loads(cache.get("project_dict"))
    dependency = Dependency(package=Package(name=dependency_name), version=dependency_version)
    project_list: list[Project] = []

    # find the usage of the dependency
    for name, project in project_dict.items():
        if (dependency_name in project.dependencies) and (project.dependencies[dependency_name].version == dependency_version):
            project_list.append(name)

    # prepare the curl request to OSV service
    headers = {"Content-Type": "application/json"}
    response = requests.post(settings.CHECK_SINGLE_PACKAGE, json=dependency.model_dump(), headers=headers)
    # check the status code
    match response.status_code:
        case 200:
            # verify if it's vulnerable and get vulnerability
            if response.json():
                vulnerabilities = response.json()["vulns"]
            else:
                vulnerabilities = "This dependency is not vulnerable."
        case _:
            # raise runtime error if the status is not 200
            logger.error("Error occurred while sending request to OSV service.")
            raise HTTPException(status_code=response.json()["code"], detail=response.json()["message"])
    
    return {"name": dependency_name, "version": dependency_version, "usage": project_list, "vulnerabilities": vulnerabilities}
